[18/03, 7:27 am]: exp 3 : GENERATE DERIVATION SECQUENCE LANGUAGE 

def generate_derivation(grammar, start_symbol, sequence, max_depth=10):
    derivation_sequences = []

    def derive(current_sequence, depth):
        if depth == 0:
            return

        for rule in grammar:
            non_terminal, production = rule.split(' -> ')
            alternatives = production.split('|')

            for alt in alternatives:
                if current_sequence.startswith(alt):
                    new_sequence = current_sequence.replace(alt, non_terminal, 1)
                    derivation_sequences.append(new_sequence)
                    derive(new_sequence, depth - 1)

    derive(sequence, max_depth)

    return derivation_sequences

# Example usage:
grammar = [
    "S -> AB",
    "A -> a|ε",
    "B -> b"
]

start_symbol = 'S'
target_sequence = 'ab'

derivation_sequences = generate_derivation(grammar, start_symbol, target_sequence)

# Output the generated derivation sequences
for i, deriv_seq in enumerate(derivation_sequences, 1):
    print(f"Derivation Sequence {i}: {deriv_seq}")





[18/03, 7:27 am] : exp 4 : ACCEPTS_THREE_CONSECUTIVE_ONES


def accepts_three_consecutive_ones(input_str):
    current_state = 'q0'

    for symbol in input_str:
        if current_state == 'q0' and symbol == '1':
            current_state = 'q1'
        elif current_state == 'q1' and symbol == '1':
            current_state = 'q2'
        elif current_state == 'q2' and symbol == '1':
            return True
        else:
            current_state = 'q0'

    return False

# Example usage:
input_str = input("Enter a binary string: ")
result = accepts_three_consecutive_ones(input_str)

if result:
    print("Accepted: The string contains three consecutive '1's.")
else:
    print("Rejected: The string does not contain three consecutive '1's.")




 exp 2 : GENERATE REGULAR EXPRESSION TO GRAMMER

import re

def generate_regex_from_grammar(grammar):
    regex_dict = {}

    for rule in grammar:
        non_terminal, production = rule.split(' -> ')
        if non_terminal not in regex_dict:
            regex_dict[non_terminal] = set()

        for symbol in production.split('|'):
            # Handle terminals (characters)
            if symbol.isalpha() and len(symbol) == 1:
                regex_dict[non_terminal].add(re.escape(symbol))

            # Handle non-terminals
            else:
                regex_dict[non_terminal].add(symbol)

    # Convert the sets to regular expressions
    for non_terminal, expressions in regex_dict.items():
        regex_dict[non_terminal] = '|'.join(expressions)

    return regex_dict

# Example usage:
grammar = [
    "S -> aA|bB",
    "A -> a|cA",
    "B -> b|d"
]

regex_dict = generate_regex_from_grammar(grammar)

# Output the generated regular expressions
for non_terminal, regex in regex_dict.items():
    print(f"{non_terminal} -> {regex}")



###₹₹#₹₹₹₹₹   input a^n b^n c^n *""""""

import pandas as pd

def check_string(input_str):
	df = pd.DataFrame(list(input_str), columns=['char'])

  # Count the occurrences of each character
  count_a = df[df['char'] == 'a'].shape[0]
  count_b = df[df['char'] == 'b'].shape[0]
  count_c = df[df['char'] == 'c'].shape[0]
  print("Number of 'a's:", count_a)
  print("Number of 'b's:", count_b)
  print("Number of 'c's:", count_c)
  return count_a == count_b == count_c and count_a > 0
  
input_str = input("Enter a string to check: ")
if check_string(input_str):
  print("Accepted")
else:
  print("Rejected")


exp 6 :

def is_divisible_by_2(input_str):
    current_state = 'q0'

    for digit in input_str:
        if current_state == 'q0' and digit in '02468':
            current_state = 'q1'
        elif current_state == 'q1' and digit in '02468':
            current_state = 'q0'
        else:
            return False

    return current_state == 'q0'

# Example usage:
input_str = input("Enter a decimal number: ")

# Check if the entered number is divisible by 2
result = is_divisible_by_2(input_str)

if result:
    print("Accepted: The decimal number is divisible by 2.")
else:
    print("Rejected: The decimal number is not divisible by 2.")
